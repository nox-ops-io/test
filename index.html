<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Я тебя люблю</title>
  <style>
    :root{
      --bg1:#ffdde1;
      --bg2:#ee9ca7;
      --bg3:#1f0a12;
    }
    html, body { height: 100%; margin: 0; }
    body {
      overflow: hidden;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 30%, var(--bg1) 0%, var(--bg2) 45%, var(--bg3) 120%);
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #fff;
    }

    .stage{
      perspective: 900px;
      width: min(92vw, 560px);
      height: min(64vh, 420px);
      display: grid;
      place-items: center;
      position: relative;
    }

    .card{
      width: 100%;
      height: 100%;
      border-radius: 28px;
      background: rgba(255,255,255,0.12);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      transform-style: preserve-3d;
      will-change: transform;
      display: grid;
      place-items: center;
      position: relative;
    }

    .glow{
      position:absolute;
      inset:-40px;
      background: radial-gradient(circle at var(--gx,50%) var(--gy,40%), rgba(255,255,255,0.35), rgba(255,255,255,0) 55%);
      filter: blur(18px);
      transform: translateZ(-40px);
      opacity: .9;
      pointer-events:none;
    }

    h1{
      margin:0;
      text-align:center;
      font-weight: 900;
      letter-spacing: -0.02em;
      font-size: clamp(42px, 7vw, 88px);
      text-shadow: 0 10px 40px rgba(0,0,0,0.45);
      transform: translateZ(55px);
      padding: 0 18px;
    }

    .sub{
      position:absolute;
      bottom: 18px;
      left: 0;
      right: 0;
      text-align:center;
      font-size: 14px;
      opacity: .9;
      transform: translateZ(28px);
    }

    .controls{
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      display:flex;
      gap:10px;
      align-items:center;
      z-index: 10;
    }

    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.25);
      color:#fff;
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 700;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    button:active{ transform: translateY(1px); }

    .hint{
      font-size: 13px;
      opacity: .85;
      max-width: 70vw;
      text-align:center;
    }

    /* small floating hearts */
    .heart{
      position:absolute;
      width: 16px;
      height: 16px;
      transform: rotate(45deg);
      background: rgba(255,255,255,0.55);
      border-radius: 3px;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.25));
      animation: float 6s linear infinite;
      opacity: .85;
      pointer-events:none;
    }
    .heart:before, .heart:after{
      content:"";
      position:absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: inherit;
    }
    .heart:before{ left:-8px; top:0; }
    .heart:after{ top:-8px; left:0; }

    @keyframes float{
      from{ transform: translate3d(var(--x,0), 120%, 0) rotate(45deg) scale(var(--s,1)); }
      to{ transform: translate3d(var(--x,0), -160%, 0) rotate(45deg) scale(var(--s,1)); }
    }
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="card" id="card" aria-label="Я тебя люблю">
      <div class="glow" id="glow"></div>
      <h1>Я тебя люблю</h1>
      <div class="sub" id="status">Наклоняй телефон ✦</div>
    </div>
  </div>

  <div class="controls">
    <button id="enable">Включить гироскоп</button>
    <button id="calibrate" style="display:none">Калибровать</button>
    <div class="hint" id="hint">На iPhone нужно разрешение. Если не работает — нажми кнопку.</div>
  </div>

  <script>
    const card = document.getElementById('card');
    const stage = document.getElementById('stage');
    const glow = document.getElementById('glow');
    const status = document.getElementById('status');
    const hint = document.getElementById('hint');
    const btn = document.getElementById('enable');
    const calBtn = document.getElementById('calibrate');

    let hasMotion = false;
    let usingGyro = false;

    // fallback: pointer tilt
    function applyTilt(xNorm, yNorm){
      const max = 14; // degrees
      const rx = (yNorm * max).toFixed(2);
      const ry = (xNorm * max).toFixed(2);
      card.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`;

      const gx = (50 + xNorm * 25);
      const gy = (40 + yNorm * 25);
      glow.style.setProperty('--gx', gx + '%');
      glow.style.setProperty('--gy', gy + '%');
    }

    stage.addEventListener('pointermove', (e)=>{
      if (usingGyro) return;
      const r = stage.getBoundingClientRect();
      const x = (e.clientX - r.left) / r.width;
      const y = (e.clientY - r.top) / r.height;
      applyTilt((x - 0.5) * 2, (y - 0.5) * 2);
    });

    // floating hearts with simple physics (react to shaking)
    const hearts = [];
    // cover the whole screen area (not only the card)
    const world = document.createElement('div');
    world.style.position = 'fixed';
    world.style.inset = '0';
    world.style.pointerEvents = 'none';
    world.style.zIndex = '1';
    document.body.appendChild(world);

    for (let i = 0; i < 42; i++) {
      const el = document.createElement('div');
      el.className = 'heart';
      el.style.left = (Math.random() * 100).toFixed(1) + '%';
      el.style.top = (Math.random() * 100).toFixed(1) + '%';
      el.style.opacity = (0.25 + Math.random() * 0.6).toFixed(2);
      world.appendChild(el);

      hearts.push({
        el,
        x: (Math.random() * 2 - 1) * 40,
        y: (Math.random() * 2 - 1) * 40,
        vx: (Math.random() * 2 - 1) * 0.8,
        vy: -(0.6 + Math.random() * 1.4),
        rot: Math.random() * 360,
        vr: (Math.random() * 2 - 1) * 2.5,
        s: 0.6 + Math.random() * 1.2,
      });
    }

    let impulseX = 0, impulseY = 0;
    function onDeviceMotion(e) {
      const a = e.accelerationIncludingGravity || e.acceleration || { x: 0, y: 0 };
      const ax = Math.max(-18, Math.min(18, a.x || 0));
      const ay = Math.max(-18, Math.min(18, a.y || 0));
      // scale down to px impulse
      impulseX = ax * 0.08;
      impulseY = -ay * 0.08;
    }

    // bounds based on viewport
    let bounds = { x: window.innerWidth * 0.55, y: window.innerHeight * 0.55 };
    window.addEventListener('resize', () => {
      bounds = { x: window.innerWidth * 0.55, y: window.innerHeight * 0.55 };
    });
    function tick() {
      for (const h of hearts) {
        h.vx += impulseX;
        h.vy += impulseY;

        // buoyancy + damping
        h.vy += -0.01;
        h.vx *= 0.985;
        h.vy *= 0.985;

        h.x += h.vx;
        h.y += h.vy;
        h.rot += h.vr;

        // bounce inside bounds
        if (h.x < -bounds.x) { h.x = -bounds.x; h.vx *= -0.75; }
        if (h.x >  bounds.x) { h.x =  bounds.x; h.vx *= -0.75; }
        if (h.y < -bounds.y) { h.y = -bounds.y; h.vy *= -0.75; }
        if (h.y >  bounds.y) { h.y =  bounds.y; h.vy *= -0.75; }

        h.el.style.transform = `translate3d(${h.x}px, ${h.y}px, 0) rotate(${45 + h.rot}deg) scale(${h.s})`;
      }
      impulseX *= 0.92;
      impulseY *= 0.92;
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // Portrait-oriented gyro with smoothing + calibration
    let gx = 0, gy = 0; // filtered norm
    let zeroX = 0, zeroY = 0;

    function calibrate(){
      zeroX = gx;
      zeroY = gy;
      status.textContent = 'Ок, откалибровано ✦';
    }

    function onDeviceOrientation(e){
      hasMotion = true;
      usingGyro = true;

      // Portrait: gamma ~ left/right, beta ~ forward/back
      const beta = Math.max(-35, Math.min(35, e.beta ?? 0));
      const gamma = Math.max(-35, Math.min(35, e.gamma ?? 0));
      const targetX = gamma / 35;
      const targetY = beta / 35;

      // low-pass filter to reduce jitter
      const a = 0.12;
      gx = gx + (targetX - gx) * a;
      gy = gy + (targetY - gy) * a;

      applyTilt(gx - zeroX, gy - zeroY);
      status.textContent = 'Гироскоп активен ✦';
      hint.textContent = 'Наклоняй телефон. Если уводит — нажми «Калибровать».';
    }

    async function enableMotion(){
      try{
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
          const perm = await DeviceOrientationEvent.requestPermission();
          if (perm !== 'granted') throw new Error('permission denied');
        }
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
          const perm2 = await DeviceMotionEvent.requestPermission();
          if (perm2 !== 'granted') throw new Error('permission denied');
        }
        window.addEventListener('deviceorientation', onDeviceOrientation, true);
        window.addEventListener('devicemotion', onDeviceMotion, true);
        calBtn.style.display = 'inline-block';
        // give it a moment
        setTimeout(()=>{
          if (!hasMotion){
            hint.textContent = 'Не вижу данных гироскопа. Проверь настройки Safari: Motion & Orientation Access.';
            status.textContent = 'Гироскоп недоступен';
          }
        }, 1200);
      } catch(err){
        hint.textContent = 'Гироскоп не разрешён. Разреши доступ к Motion/Orientation и попробуй снова.';
        status.textContent = 'Нужен доступ';
      }
    }

    btn.addEventListener('click', enableMotion);
    calBtn.addEventListener('click', calibrate);

    // try auto-enable where possible
    // (won't work on iOS without user gesture)
    if (!(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function')){
      enableMotion();
    } else {
      hint.textContent = 'Нажми «Включить гироскоп», чтобы работал наклон на iPhone.';
    }
  </script>
</body>
</html>
